##  数据库索引

### 索引数据结构

**为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？**

#### Hash

字段值所对应的数组下标是哈希算法随机算出来的，所以可能出现哈希冲突

对于这样一个索引结构，执行下面的sql语句：

```
select * from table where name='鸡蛋'
```

可以直接对'鸡蛋'按照哈希算法算出来数组下标，然后可以直接从数据中提取数据并拿到对应那一行的数据的地址，进而查询那一行数据。那么如果执行下面的sql语句：

```
select * from sanguo where name>'鸡蛋'
```

现在则无能为力，因为哈希表的特点是可以快速的精确查询，但是不支持范围查询，如果做成索引，速度也是很慢的，也是也要全部扫描。

- 题外话，Hash表在哪些场景比较适合？

  等值查询的场景，就只有KV（Key，Value）的情况，例如Redis、Memcached等这些NoSQL的中间件。

#### 有序数组

有序数组在等值查询与范围查询的时候都很不错。

- 缺点

  有序的数组适合存储静态数据，因为新增、删除和修改数据都会改变它的结构，维护成本高。

#### 二叉树

二叉树是有序的，所以是支持范围查询的。时间复杂度是O(log(N))，为了维持这个时间复杂度，更新的时间复杂度也是O(log(N))，那就得保持这棵树完全平衡二叉树。

- 缺点

  数据过多时，树高会很高，查询的成本会随着树高的增加而增加。为了节约成本很多公司的硬盘还是机械硬盘，查询时间也比较长。

#### B树

同样的元素，B树的表示比完全平衡二叉树要矮，原因在于B树中的一个节点可以存储多个元素。

#### B+树

B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。

- B+树的优势

  最开始的Hash不支持范围查询，二叉树树高很高，只有B树跟B+有的一比。

  B树一个节点可以存储多个元素，相对于完全平衡二叉树整体的树高降低了，磁盘IO效率提高了。

  而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是为了提高范围查找的效率。

  提高了的原因也无非是会有指针指向下一个节点的叶子节点

#### 小结

Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。



### 索引基础知识

#### B+树中一个节点到底多大合适

- B+树中一个节点为**一页或页的倍数**最为合适。

- 因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。


- 如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。


- 所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。

#### 页

MySQL的基本存储结构是**页**（记录都存在页里面）

![InnoDB页结构示意图](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/InnoDB页结构示意图.6nt55hg31t40.jpg)

![InnoDB插入记录](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/InnoDB插入记录.knwtkuklv1c.jpg)

- **各个数据页**可以组成一个**双向链表**

- **每个数据页中的记录**又可以组成一个**单向链表**

- 每个数据页都会为存储在页中的记录生成一个**页目录**，在通过**主键**查找某条记录的时候可以在页目录中**二分法快速定位**到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

- 以**其他列**(非主键)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

所以说，如果我们写 select * from user where username='丙丙'这样没有进行任何优化的sql语句，默认会这样做：

定位到记录所在的页

- 需要遍历双向链表，找到所在的页

从所在的页内中查找相应的记录

- 由于不是根据主键查询，只能遍历所在页的单链表了

很明显，在数据量很大的情况下这样查找会很慢！看起来跟回表有点点像。

#### 回表

回表大概就是有个主键为ID的索引，和一个普通name字段的索引，在普通字段上搜索：

```
sql select * from table where name = 'han'
```


执行的流程是先查询到name索引上的“han”，然后找到他的id是2，最后去主键索引，找到id为2对应的值。

**回到主键索引树搜索**的过程，就是**回表**。不过也有方法避免回表，那就是**覆盖索引**。

#### 覆盖索引

刚才是 select * ，查询所有的，如果只查询ID那，其实在Name字段的索引上就已经有了，那就不需要回表了。

覆盖索引可以减少树的搜索次数，提升性能，他也是在实际开发过程中经常用来优化查询效率的手段。

很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率

#### 最左匹配原则

- 索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
- 列的排列顺序决定了可命中索引的列数
- 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)



### 总结

- **最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。
- 尽量选择**区分度高的列作为索引**，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。

- **索引列不能参与计算**，尽量保持列“干净”。比如， FROM_UNIXTIME(create_time)='2016-06-06' 就不能使用索引，原因很简单，**B+树中存储的都是数据表中的字段值**，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ：create_time=UNIX_TIMESTAMP('2016-06-06')。
- 尽可能的**扩展索引**，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。

