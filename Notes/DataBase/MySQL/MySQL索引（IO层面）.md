## MySQL索引（IO层面）

### MySQL的索引本质上是一种数据结构

### 计算机的数据加载

#### 磁盘IO

![磁盘](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/磁盘.71jxagrehxs0.jpg)

磁盘IO，磁盘读取数据靠的是机械运动，每一次读取数据需要**寻道、寻点、拷贝到内存**三步操作。

- **寻道时间**

  **寻道**时间是磁臂移动到指定磁道所需要的时间，一般在5ms以下。

- **寻点**

  **寻点**是从磁道中找到数据存在的那个点，平均时间是半圈时间，如果是一个7200转/min的磁盘，寻点时间平均是600000/7200/2=4.17ms;

- **拷贝到内存**

  **拷贝到内存**的时间很快，和之前两个时间相比可以忽略不记，所以**一次IO的时间平均在9ms左右**。数据库百万级别的数据过一遍就达到了9000s，显然就是灾难级别。

![磁盘详情](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/磁盘详情.2ifq8305shy0.jpg)

![磁头柱面](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/磁头柱面.2wqhxrg06xe0.jpg)

#### 预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了预读的优化，当一次IO时，不光把当前磁盘地址的数据，读入到内存缓冲区，而是把**相邻的数据**也都读入内存缓冲区内，因为当计算机访问一个地址的数据的时候，与其相邻的数据也很快会被访问到。

- **页**

  每一次IO读取的数据称之为**一页（page）**，具体一页有多大数据跟操作系统相关，一般为**4k或者8k**，也就是说读取一页内的数据的时候，实际上才发生了一次IO。

  **注意：硬盘的最小存储单位就是扇区了，而且硬盘本身并没有block的概念。**

  **操作系统的文件系统**

  文件系统不是一个扇区一个扇区的来读数据，太慢了，所以有了block（块）的概念，它是一个块一个块的读取的，block才是文件存取的最小单位。

  ```
  # df -T
  /dev/cciss/c0d0p5  ext3  112738028 81733116 25185772 77% /
  ```

  **ext3文件系统** 。

  ```
  # tune2fs -l /dev/cciss/c0d0p5 | grep "Block size"
  Block size:        4096
  ```

  **一个block是4K**

  **简单的说扇区是对硬盘而言，块是对文件系统而言**

想要优化数据库查询，就要**尽量减少磁盘的IO操作**，所以就出现了索引。



### 索引

**MySQL**官方对索引的定义为：**索引(Index)**是帮助**MySQL**高效获取数据的数据结构。

**MySQL**中常用的索引在物理上分两类，**B-树索引**和**哈希索引**。

#### BTree

**BTree**又叫多路平衡查找树，一颗m叉的BTree特性如下：

- 树中每个节点最多包含m个孩子。

- 除根节点与叶子结点以外，每个节点至少有[ceil(m / 2)]个孩子（ceil()为向上取整）。

- 若根节点不是叶子节点，则至少有两个孩子。

- 所有叶子节点都在同一层。

- 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m / 2) - 1] <= n <= m-1

  ![Btree](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/Btree.z6yafymums0.png)

  **（中间子节点只有一个孩子节点，有待考证（可以认为是图画不下，因为所有叶子节点都在同一层，且有k个关键字的节点一定有k+1个孩子节点））**

  这是一个3叉（只是举例，真实会有很多叉）的BTree结构图，每一个方框块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应四个扇区，紫色代表的是磁盘块中的数据key，黄色代表的是数据data，蓝色代表的是指针p，指向下一个磁盘块的位置。

模拟下查找key为29的data的过程：

1. 根据根结点指针读取文件目录的根磁盘块1。【**磁盘IO操作1次**】
2. 磁盘块1存储17，35和三个指针数据。我们发现17<29<35，因此我们找到指针p2。
3. 根据p2指针，我们定位并读取磁盘块3。【**磁盘IO操作2次**】
4. 磁盘块3存储26，30和三个指针数据。我们发现26<29<30，因此我们找到指针p2。
5. 根据p2指针，我们定位并读取磁盘块8。【**磁盘IO操作3次**】
6. 磁盘块8中存储28，29。我们找到29，获取29所对应的数据data。

由此可见，BTree索引使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。

从图上可以看到，每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。



#### B+Tree

**B+Tree**是在**B-Tree**基础上的一种优化，使其更适合实现外存储索引结构。在B+Tree中，所有的数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点只存储key值信息，这样大大增加了每个节点存储的key值数量，降低B+Tree的高度。

![Btree](https://cdn.jsdelivr.net/gh/hanmlian/image-hosting@master/DataBase/Btree.z6yafymums0.png)

- **B+Tree相对于B-Tree有几点不同：**

  1. 非叶子节点只存储键值信息，数据记录都存放在叶子节点中，所以B+Tree的高度可以被压缩到很低。

     具体的数据如下：

     InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或者 BIGINT（占用8个字节），指针类型页一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。
     也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。（这种计算方式存在误差，而且没有计算叶子节点，如果计算叶子节点其实是深度为4了）

  2. B+Tree上通常有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。所以我们除了可以对B+Tree进行主键的范围查找和分页查找，还可以从根节点开始随机查找。

- 数据库中的B+Tree索引可以分为**聚集索引（clustered index）**和**辅助索引（secondary index）**。

  上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据，**辅助索引**与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是**存储相应行数据的聚集索引键，即主键**。

  当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。（**回表**）

- **弊端**

  不过，虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下**弊端**：

  1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
  2. 除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。
  3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。
  4. 注意：索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。

- **建立索引的原则**

  - 在经常需要搜索的列上建立索引，可以加快搜索的速度。
  - 在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。
  - 在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。
  - 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。
  - 在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询。
  - 在经常使用 WHERE 子句的列上创建索引，加快条件的判断速度。







